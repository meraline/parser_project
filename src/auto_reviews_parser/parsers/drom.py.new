"""Парсер отзывов с Drom.ru с использованием Playwright."""

from typing import Dict, List, Optional, Tuple
import logging
from urllib.parse import urlparse

from playwright.sync_api import sync_playwright, Page

from .base import BaseParser
from ..models.review import Review

logger = logging.getLogger(__name__)


class DromParser(BaseParser):
    """Парсер для сайта Drom.ru."""
    
    def __init__(self):
        """Инициализация парсера."""
        super().__init__()
        self.base_url = "https://www.drom.ru"
        self.selectors = {
            "review_block": ".b-comments__item",
            "review_link": "a.b-comments__item__link",
            "next_page": ".b-pagination__next",
        }

    def parse_reviews(self, brand: str, model: str) -> List[Review]:
        """Parse reviews for given brand and model.

        Args:
            brand: Car brand name
            model: Car model name

        Returns:
            List of parsed reviews

        Raises:
            NetworkError: On network-related errors
            ParseError: On parsing errors
        """
        # На drom.ru мы можем искать по бренду и получать все отзывы, включая заданную модель
        reviews = self.parse_catalog(brand)
        # Фильтруем только отзывы для нужной модели
        return [review for review in reviews if review.model.lower() == model.lower()]

    def _extract_brand_model(self, url: str) -> Tuple[str, str]:
        """Извлекает марку и модель из URL.

        Args:
            url: URL отзыва или каталога

        Returns:
            Кортеж (марка, модель)
        """
        path = urlparse(url).path
        parts = [p for p in path.split("/") if p]

        if len(parts) >= 3 and parts[0] == "reviews":
            return parts[1], parts[2]

        return "", ""

    def _go_to_page(self, page: Page, url: str) -> None:
        """Переходит на страницу и ждет ее загрузки.

        Args:
            page: Объект страницы Playwright
            url: URL страницы
        """
        page.goto(url)
        page.wait_for_load_state("networkidle")

    def parse_catalog(self, brand: str, max_reviews: int = 1000) -> List[Review]:
        """Парсит отзывы о бренде.

        Args:
            brand: Название бренда
            max_reviews: Максимальное количество отзывов

        Returns:
            Список отзывов
        """
        reviews = []
        url = f"{self.base_url}/reviews/{brand.lower()}/"

        with sync_playwright() as p:
            browser = p.chromium.launch(headless=True)
            page = browser.new_page()

            try:
                self._go_to_page(page, url)

                while len(reviews) < max_reviews:
                    blocks = page.query_selector_all(self.selectors["review_block"])

                    for block in blocks:
                        link = block.query_selector(self.selectors["review_link"])
                        if not link:
                            continue

                        review_url = link.get_attribute("href")
                        if not review_url:
                            continue

                        if not review_url.startswith("http"):
                            review_url = f"{self.base_url}{review_url}"

                        self._go_to_page(page, review_url)

                        content = page.content()
                        brand, model = self._extract_brand_model(review_url)

                        review = Review(
                            source="drom.ru",
                            type="review",
                            url=review_url,
                            brand=brand,
                            model=model,
                            content=content
                        )
                        reviews.append(review)

                        if len(reviews) >= max_reviews:
                            break

                        self._go_to_page(page, url)

                    next_button = page.query_selector(self.selectors["next_page"])
                    if not next_button:
                        break

                    next_button.click()
                    page.wait_for_load_state("networkidle")

            finally:
                browser.close()

        return reviews
